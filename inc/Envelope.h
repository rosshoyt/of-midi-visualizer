#pragma once
#include "ofMain.h"
#include <vector>
#include "spline.h"
#include "Utils.h"
#include "EnvelopeSettings.h"



class Envelope {
public:
    Envelope(EnvelopeSettings settings) : settings(settings) {
    }
    Envelope() : settings(EnvelopeSettings()) {};

    double getLevel(long timeSinceStart, long timeSinceEnd, float lastNoteLevel = 0) {
        return getLevel(settings, timeSinceStart, timeSinceEnd, lastNoteLevel);
    }
    // TODO Refactor to accept EnvelopeNodeSettings instead of timeSinceStart, timeSinceEnd and lastNoteLevel
    double getLevel(EnvelopeSettings stgs, long timeSinceStart, long timeSinceEnd, float lastNoteLevel = 0) {
       
        std::string debug;

        double level = 0;

        // check if note is currently engaged.
        bool heldNote = timeSinceEnd > timeSinceStart;


        // flag which will be set to the amount of time past the start of the release
        //double timePastRelease = -1; 
        bool heldNoteButMayBeReleasing = false;
        if (heldNote) {
            long timeThreshold = stgs.lengthA;

            //double lengthSeg, levelSegStart,  levelSegEnd,  levelSpline;
            if (timeThreshold > timeSinceStart) {
                // attacking 
                // TODO refactor all these getLevel calls to accept an EnvelopeSegmentSettings&, generated by EnvelopeSettings constructor
                level = getLevel(timeSinceStart, stgs.lengthA, 0, stgs.levelA, stgs.splineA);
                debug = "ATTACKING";
            }
            else if ((timeThreshold += stgs.lengthD) > timeSinceStart) {
                // decaying
                level = getLevel(timeSinceStart - stgs.lengthA, stgs.lengthD, stgs.levelA, stgs.levelD, stgs.splineD);
                debug = "DECAYING";
            }
            else if (stgs.sustain) {
                // sustaining
                level = stgs.levelD;//getLevel(timeSinceStart - stgs.lengthA - stgs.lengthD, st)
                debug = "SUSTAINING";
            }
            else {
                // timePastRelease = timeSinceStart - timeThreshold;
                heldNoteButMayBeReleasing = true;
            }

            //std::cout << "Note was under TimeThreshold was " << timeThreshold << std::endl;
        }

        if ((!heldNote && timeSinceEnd < stgs.lengthR) || heldNoteButMayBeReleasing) {
            // releasing
            level = getLevel(timeSinceEnd, stgs.lengthR, lastNoteLevel != 0 ? lastNoteLevel : stgs.levelD, 0, stgs.splineR);
            debug = heldNoteButMayBeReleasing ? "Held Down but not sustaining" : "Releasing";

        }

        debug = debug == "" ? "Inactive" : debug;

        std::cout << "Time Since Start: " << timeSinceStart << " State: " << debug << " Value = " << level << std::endl;
        
        
        this->settings = stgs;


        return level;
    }

    double getReleaseLength() {
        return settings.lengthR;

    }
    //void start(){}
private:
    EnvelopeSettings& settings;
    enum EnvelopeRegion {
        ATTACK, SUSTAIN, DECAY, RELEASE
    };

    float getLevel(double segTimeElapsed, double lengthSeg, double levelSegStart, double levelSegEnd, double levelSpline) {

        std::vector<double> splineControlX, splineControlY;

        //int numInternalControlSegments = 3; // TODO use named variable instead of 'magic number'

        // setup 6-point control spline in default state (linear)
        double xStepSize = lengthSeg / 3;
        double yStepSize = (levelSegEnd - levelSegStart) / 3;
        double yVal = levelSegStart - yStepSize;
        double xVal = -xStepSize;//settings.start - xStepSize;
        for (int i = 0; i < 6; ++i, xVal += xStepSize, yVal += yStepSize) {
            splineControlY.push_back(yVal);
            splineControlX.push_back(xVal);
            //std::cout << "Xval = "<< xVal << " Yval = " << yVal << " Xval (relative) = " << splineControlXRelative[i] <<'\n';
        }

        if (levelSpline != 0) {
            // TODO change the direction of the control points depending on segment slope being positive, negative (or 0?)
            // double change = levelSegStart > levelSegEnd ? -change : change;
            // TODO also add error correction so that spline values are not toop big/small
            splineControlY[0] -= levelSpline;
            splineControlY[2] += levelSpline;
            splineControlY[3] += levelSpline;
            splineControlY[5] -= levelSpline;
        } // else { linear interpolate to save processing power? }; // TODO

        tk::spline spline;

        spline.set_points(splineControlX, splineControlY);


        return spline(segTimeElapsed);
    }


};

class EnvelopeNodeSettings {

};

// Class which manages state information for an object using an envelope
class EnvelopeNode {
public:
	EnvelopeNode(Envelope* envelope);

	float getLevel(long currentTimeMS);

	float getLevel();

	void start(int velocity);

	// function called when a note is pressed down (via Note On)
	void start();
	
	// function called when a note is released (via Note Off or Sustain Pedal Off)
	void stop();

	long getLastStartTimeMS();

	long getLastStopTimeMS();

	int getLastNoteOnVelocity();

private:
	Envelope* envelope;

	long lastStart = 0, lastStop = 0;
	
	int lastNoteOnVelocity = 0;
};

