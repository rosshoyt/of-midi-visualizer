#pragma once
#include "ofMain.h"
#include <vector>
#include "spline.h"
#include "Utils.h"

class EnvelopeSegmentSettings {
public:
	double start = 0, startLevel = 0, end = 500, endLevel = 1;
};

class EnvelopeSegment {
public:
	EnvelopeSegment(EnvelopeSegmentSettings settings);

	// TODO could refactor - store calculated value to avoid calculating redundantly?
	// Must call containsTime() to ensure segment contains valid value for time value
	float getLevel(double timeSinceNoteStart);

	// TODO combine with getLevel method? could use boolean flag
	float getLevelForRelativeTime(double timeSinceStartOfThisEnvelopeSegment); 

	double getLength();

	float getStartingLevel();

	bool containsTime(double elapsedTimeMS);

	// Public GUI Sliders
	ofParameter<float> splineIntensitySlider;
	ofParameter<double> lengthSlider;

private:

	void init();

	std::vector<double> getSplineYControlsWithIntensity();

	// PRIVATE Fields
	EnvelopeSegmentSettings settings;

	// Derived values
	double totalLength;

	// spline control values 
	std::vector<double> splineControlX, splineControlY;

	// Relative control values that has envelope start time as 0
	std::vector<double> splineControlXRelative;

	// constants
	const int NUM_INTERNAL_CONTROL_SEGMENTS = 3;
	const float MAX_SPLINE_CONTROL_PERC = 0.88888888; // so that control points don't put spline above/below target val
};

enum EnvelopeType { ADR, ADSR };

class EnvelopeSettings {
public:
	std::vector<double> envSegmentLengths = { 30, 2000, 1000 };
	std::vector<double> envSegmentLevels  = { 0.f, 1.f, .5f };
	EnvelopeType envelopeType = EnvelopeType::ADSR;
};

class Envelope {
public:
	Envelope(EnvelopeSettings envelopeSettings);

	// no-args constructor which sets default envelopeADR settings
	Envelope();

	EnvelopeType getEnvelopeType();

	double getLevel(long timeSinceStart, long timeSinceEnd, float lastNoteLevel = 0) {
		std::string debug;

		double level = 0;

		// check if note is currently engaged.
		bool heldNote = timeSinceEnd > timeSinceStart;


		// flag which will be set to the amount of time past the start of the release
		//double timePastRelease = -1; 
		bool heldNoteButMayBeReleasing = false;
		if (heldNote) {
			long timeThreshold = lengthA;

			//double lengthSeg, levelSegStart,  levelSegEnd,  levelSpline;
			if (timeThreshold > timeSinceStart) {
				// attacking 
				// TODO refactor all these getLevel calls to accept an EnvelopeSegmentSettings&, generated by EnvelopeSettings constructor
				level = getLevel(timeSinceStart, lengthA, 0, levelA, splineA);
				debug = "Attacking";
			}
			else if ((timeThreshold += lengthD) > timeSinceStart) {
				// decaying
				level = getLevel(timeSinceStart - lengthA, lengthD, levelA, levelD, splineD);
				debug = "Decaying";
			}
			else if (sustain) {
				// sustaining
				level = levelD;//getLevel(timeSinceStart - lengthA - lengthD, st)
				debug = "Sustaining";
			}
			else {
				// timePastRelease = timeSinceStart - timeThreshold;
				heldNoteButMayBeReleasing = true;
			}

			//std::cout << "Note was under TimeThreshold was " << timeThreshold << std::endl;
		}

		if ((!heldNote && timeSinceEnd < lengthR) || heldNoteButMayBeReleasing) {
			// releasing
			debug = heldNoteButMayBeReleasing ? "Held Down but not sustaining" : "Releasing";
			level = getLevel(timeSinceEnd, lengthR, lastNoteLevel > 0 ? lastNoteLevel : levelD, 0, splineR);
		}

		debug = debug == "" ? "Inactive" : debug;

		//std::cout << "Time Since Start: " << timeSinceStart << " State: " << debug << " Value = " << level << std::endl;
		return level;
	}


	// method which gets the value of the envelope based on the time since start.
	// returns -1 if the time is not part of the envelope
	//float getLevel(double timeSinceNoteStart, double timeSinceNoteOff);

	//float getLevel(long timeSinceNoteStart, long timeSinceNoteOff);

	double getLength();

	double getAttackLength();

	double getDecayLength();

	double getReleaseLength();

	ofParameterGroup guiParams;

private:
	double lengthA = 250, lengthD = 1500, lengthR = 250;
	double levelA = 1, levelD = .5;
	double splineA = .1, splineD = -.1, splineR = -.1;
	bool sustain = false;


	float getLevel(double segTimeElapsed, double lengthSeg, double levelSegStart, double levelSegEnd, double levelSpline) {

		std::vector<double> splineControlX, splineControlY;

		//int numInternalControlSegments = 3; // TODO use named variable instead of 'magic number'

		// setup 6-point control spline in default state (linear)
		double xStepSize = lengthSeg / 3;
		double yStepSize = (levelSegEnd - levelSegStart) / 3;
		double yVal = levelSegStart - yStepSize;
		double xVal = -xStepSize;//settings.start - xStepSize;
		for (int i = 0; i < 6; ++i, xVal += xStepSize, yVal += yStepSize) {
			splineControlY.push_back(yVal);
			splineControlX.push_back(xVal);
			//std::cout << "Xval = "<< xVal << " Yval = " << yVal << " Xval (relative) = " << splineControlXRelative[i] <<'\n';
		}

		if (levelSpline != 0) {
			// TODO change the direction of the control points depending on segment slope being positive, negative (or 0?)
			// double change = levelSegStart > levelSegEnd ? -change : change;
			// TODO also add error correction so that spline values are not toop big/small
			splineControlY[0] -= levelSpline;
			splineControlY[2] += levelSpline;
			splineControlY[3] += levelSpline;
			splineControlY[5] -= levelSpline;
		} // else { linear interpolate to save processing power? }; // TODO

		tk::spline spline;

		spline.set_points(splineControlX, splineControlY);


		return spline(segTimeElapsed);
	}

	void init();

	std::vector<EnvelopeSegment*> envelopeSegments;
	EnvelopeSettings envelopeSettings;

	double totalLength;
};

// Class which manages state information for an object using an envelope
class EnvelopeNode {
public:
	EnvelopeNode(Envelope* envelope);

	float getLevel(long currentTimeMS);

	float getLevel();

	void start(int velocity);

	// function called when a note is pressed down (via Note On)
	void start();
	
	// function called when a note is released (via Note Off or Sustain Pedal Off)
	void stop();

	long getLastStartTimeMS();

	long getLastStopTimeMS();

	int getLastNoteOnVelocity();

private:
	Envelope* envelope;

	long lastStart = 0, lastStop = 0;
	
	int lastNoteOnVelocity = 0;
};